//====================================================================
//文件名称：main.c（应用工程主函数）
//框架提供：SD-Arm（sumcu.suda.edu.cn）
//版本更新：20170801-20200502
//功能描述：见本工程的<01_Doc>文件夹下Readme.txt文件
//====================================================================

#define GLOBLE_VAR
#include "includes.h" //包含总头文件

//----------------------------------------------------------------------
//声明使用到的内部函数
//main.c使用的内部函数声明处

//----------------------------------------------------------------------
//主函数，一般情况下可以认为程序从此开始运行（实际上有启动过程见书稿）
int main(void)
{
    //（1）======启动部分（开头）==========================================
    //（1.1）声明main函数使用的局部变量
    uint32_t mMainLoopCount; //主循环使用的记录主循环次数变量

    //（1.2）【不变】关总中断
    DISABLE_INTERRUPTS;
    wdog_stop();

    //1. 找到PORTC端口的基地址，可以参考KL36参考手册
    volatile uint32_t *portC_ptr = (uint32_t *)0x4004B000u;

    //2. 找到 portC_PCR_0引脚控制寄存器的地址 = 基地址 + 偏移量
    volatile uint32_t *portC_pcr_0 = portC_ptr + 0;

    //3. 将PORTC端口的0号引脚设置成GPIO
    *portC_pcr_0 &= 0b11111111111111111111100011111111; //清MUX位段
    *portC_pcr_0 |= 0b00000000000000000000000100000000;

    //4. 找到PORTC端口GPIO寄存器的基地址为 0x400FF080u
    volatile uint32_t *gpioC_ptr = (uint32_t *)0x400FF080u;

    //5. 找到PORTC端口的数据方向寄存器地址 = 基地址 + 偏移量
    volatile uint32_t *portC_pddr = gpioC_ptr + 5;

    //6. 找到PORTC端口的数据输出寄存器地址 = 基地址 + 偏移量
    volatile uint32_t *portC_pdor = gpioC_ptr + 0;

    //7. 通过设置PORTC的GPIO数据输出寄存器第0位为1，来完成初始化
    *portC_pdor |= (1 << 0);

    //8. 设置PORTC的GPIO数据方向寄存器，令PORTC的0号引脚为输出
    *portC_pddr |= (1 << 0);

    //9. 点亮小灯
    *portC_pdor &= ~(1 << 0);

    //（1.7）【不变】开总中断
    ENABLE_INTERRUPTS;
}

//======以下为主函数调用的子函数存放处===================================

//======================================================================
/*
知识要素：
（1）main.c是一个模板，该文件所有代码均不涉及具体的硬件和环境，通过调用构件
实现对硬件的干预。
（2）本文件中标有【不变】的地方为系统保留，此类代码与具体项目无关，不宜删除。
（3）本文件中对宏GLOBLE_VAR进行了定义，所以在包含"includes.h"头文件时，会定
义全局变量，在其他文件中包含"includes.h"头文件时，
编译时会自动增加extern
*/