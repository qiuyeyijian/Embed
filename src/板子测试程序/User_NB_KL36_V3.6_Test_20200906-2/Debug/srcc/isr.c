//=====================================================================
//文件名称：isr.c（中断处理程序源文件）
//框架提供：SD-ARM（sumcu.suda.edu.cn）
//版本更新：20170801-20191020
//功能描述：提供中断处理程序编程框架
//=====================================================================
#include "includes.h"
static int countKey=0;    //LPT中断计数
//声明使用到的内部函数
//isr.c使用的内部函数声明处
void SecAdd1(uint8_t *p);

//======================================================================
//参数说明：无
//函数返回：无
//功能概要：串口UE接收中断服务程序
//======================================================================
void UART_UE_Handler(void)
{
    uint8_t ch;
    uint8_t flag;
    DISABLE_INTERRUPTS;      //关总中断
    //-------------------------------
    //接收一个字节
    ch = uart_re1(UART_UE, &flag);   //调用接收一个字节的函数，清接收中断位
    
    //串口数据接收失败，退出
    if(!flag) goto UART_UE_IRQHandler_Exit;
    //gcRecvLen为0，表示上一帧数据处理接收，可重新接收数据
    if(gcRecvLen == 0)                           //组帧
    uecom_interrupt(ch,&gcRecvLen,gcRecvBuf);  
    else                                         //丢弃           
    goto UART_UE_IRQHandler_Exit;
    //未接收到服务器发来的数据，退出
    if(gcRecvLen == 0) goto UART_UE_IRQHandler_Exit;
    //已经收到一帧字节数为gcRecvLen，在gcRecvBuf中，由main.c处理
    UART_UE_IRQHandler_Exit:
    //-------------------------------
    ENABLE_INTERRUPTS;       //开总中断
}




//=====================================================================
//参数说明：无
//函数返回：无
//功能概要：（1）每20ms中断触发本程序一次；（2）达到一秒时，调用秒+1
//           程序，计算“时、分、秒”
//特别提示：（1）使用全局变量字节型数组gTime[3]，分别存储“时、分、秒”
//        （2）注意其中静态变量的使用
//=====================================================================
void TIMER_USER_Handler(void)
{
    DISABLE_INTERRUPTS;                        //关总中断
    //------------------------------------------------------------------
    //（在此处增加功能）
    //申请一个静态的计数器值
    static uint8_t TimerCount = 0;
    //获取当前时钟溢出标志位
    if(timer_get_int(TIMER_USER))
    {
        TimerCount++;           //计数器累加
        if (TimerCount >= 50)   
        {
            TimerCount = 0;    //时钟计数器清零
            SecAdd1(gTimeString);    //时间显示累加
        }
        timer_clear_int(TIMER_USER);    //清时钟溢出标志位
    }
    //------------------------------------------------------------------
    ENABLE_INTERRUPTS;                        //开总中断
    
}


//===========================================================================
//函数返回：无
//参数说明：*p:为指向一个时分秒数组，格式为：hh:mm:ss,ASCII码形式，
//             p+11为时的十位，p+18为秒的个位，注意有“:”在其中
//             （00:00:00-23:59:59)
//功能概要：秒的个位+1，按照时间规则进行后续运算,不对日进行运算
//修改记录：【WYH】规范程序
//         【20200903】显示时间（乱码问题）测试
//===========================================================================
void SecAdd1(uint8_t *p)
{
    //（1）秒的个位+1
    *(p+18)+=1;        //秒的个位+1  
    if((*(p+18)<=0x39)) goto SecAdd1_Exit;
    //（2）秒的个位满，对秒的十位进行运算
    *(p+18)=0x30;   //秒的个位清0
    *(p+17)+=1;     //秒的十位+1
    if((*(p+17)<=0x35)) goto SecAdd1_Exit; 
    //（3）秒的十位满，对分的个位进行运算
    *(p+18)=0x30;    //秒的个位清0
    *(p+17)=0x30;    //秒的十位清0
    *(p+15)+=1;      //分的个位+1
    if((*(p+15)<=0x39)) goto SecAdd1_Exit; 
    //（4）分的个位满，对分的十位进行运算
    *(p+18)=0x30;  //秒的个位清0
    *(p+17)=0x30;  //秒的十位清0
    *(p+15)=0x30;  //分的个位清0
    *(p+14)+=1;    //分的十位+1
    if((*(p+14)<=0x35)) goto SecAdd1_Exit; 
    //（5）分的十位满，对时的个位进行运算
    *(p+18)=0x30;   //秒的个位清0
    *(p+17)=0x30;   //秒的十位清0
    *(p+15)=0x30;   //分的个位清0  
    *(p+14)=0x30;   //分的十位清0
    *(p+12)+=1;     //时的个位+1 
    if ((*(p+11)<=0x31) && (*(p+12)<=0x39) && (*(p+12)>=0x31)
          || (*(p+11)>=0x32)
          && (*(p+11)<=0x39)) goto SecAdd1_Exit;
    //(6) 时的个位满，对时的十位继续运算
        *(p+18)=0x30;   //秒的个位清0
        *(p+17)=0x30;   //秒的十位清0
        *(p+15)=0x30;   //分的个位清0  
        *(p+14)=0x30;   //分的十位清0
        *(p+12)=0x30;   //时的个位清0 
        *(p+11)+=1;      //时的十位+1 
//    if ((*(p+11)>=0x32) && (*(p+12)<=0x33)) goto SecAdd1_Exit;
//     (7) 小时的十位满，对日的个位继续运算
//        *(p+18)=0x30;   //秒的个位清0
//        *(p+17)=0x30;   //秒的十位清0
//        *(p+15)=0x30;   //分的个位清0  
//        *(p+14)=0x30;   //分的十位清0
//        *(p+12)=0x30;   //时的个位清0
//        *(p+11)=0x30;   //时的十位清0
    
 SecAdd1_Exit:
    __asm("nop");
}
//===========================================================================
//函数返回：无
//参数说明：无
//功能概要：红外寻迹
//===========================================================================
void PORTC_PORTD_IRQHandler_Ray(void)
{

	DISABLE_INTERRUPTS;                       //关总中断
	//------------------------------------------------------------------
	if(gpio_get_int(RAY_LEFT))
	{
		gpio_clear_int(RAY_LEFT);
		printf("左侧红外检测有物体\r\n");
	
	}
	if(gpio_get_int(RAY_RIGHT))
	{
		gpio_clear_int(RAY_RIGHT);
		printf("右侧红外检测有物体\r\n");
	}
	
	//------------------------------------------------------------------
    ENABLE_INTERRUPTS;                        //开总中断
} 
//===========================================================================
//函数返回：无
//参数说明：无
//功能概要：人体红外 
//===========================================================================
void PORTC_PORTD_IRQHandler_Human(void)
{
	DISABLE_INTERRUPTS;                       //关总中断
	//------------------------------------------------------------------

	if(gpio_get_int(RAY_HUMAN))
	{
		gpio_clear_int(RAY_HUMAN);
		printf(" 红外检测有人\r\n");
	}	
	//------------------------------------------------------------------
    ENABLE_INTERRUPTS;                        //开总中断
}
//===========================================================================
//函数返回：无
//参数说明：无
//功能概要：Button测试
//程序名称：TIMER_USER_Handler_Button（TIMERA模块中断处理程序）
//触发条件：定时器计时达到初始化时设置的计时间隔时，触发定时器溢出中断
//===========================================================================
void TIMER_USER_Handler_Button(void)
{
	DISABLE_INTERRUPTS;                       //关总中断
	//------------------------------------------------------------------
	//（在此处增加功能）
	timer_clear_int(TIMER_USER);                //清中断标志
	//Button1为0，Button2为1,检测switch1、switch2的状态
	if(countKey%2==0)
	{
		gpio_set(Button1,0);
		gpio_set(Button2,1);
		if(gpio_get(PTC_NUM|3)==0)
		{
			//Button3为低，说明switch1闭合
			switch1=1;
			printf("Button1 on\r\n");
		}
		else if(gpio_get(PTC_NUM|3)==1)
		{
			//Button3为高，说明switch1断开
			switch1=0;
		}
	
		if(gpio_get(PTC_NUM|0)==0)
		{
			//Button4为低，说明switch2闭合
			switch2=1;
			printf("Button2 on\r\n");
		}
		else if(gpio_get(PTC_NUM|0)==1)
		{
			//Button4为高，说明switch2断开
			switch2=0;			
		}
	}	
	else
	{
		//Button1为1，Button2为0,检测switch3、switch4的状态
		gpio_set(Button1,1);
		gpio_set(Button2,0);
		if(gpio_get(Button3)==0)
		{
			//Button3为低，说明switch3闭合
			switch3=1;
			printf("Button3 on\r\n");
		}
		else if(gpio_get(Button3)==1)
		{
			//Button3为高，说明switch3断开
			switch3=0;
			//printf("3 off\r\n");
		}
	
		if(gpio_get(Button4)==0)
		{
			//Button4为低，说明switch4闭合
			switch4=1;
			printf("Button4 on\r\n");
		}
		else if(gpio_get(Button4)==1)
		{
			//Button4为高，说明switch4断开
			switch4=0;
			//printf("3 off\r\n");
		}	
	}
	if(countKey>100)
	{
		countKey=0;
	}
	countKey++;
	//------------------------------------------------------------------
	ENABLE_INTERRUPTS;                        //开总中断
}


/*
知识要素：
1.本文件中的中断处理函数调用的均是相关设备封装好的具体构件，在更换芯片
时，只需保证设备的构件接口一致，即可保证本文件的相关中断处理函数不做任何
更改，从而达到芯片无关性的要求。
*/





